// Copyright 2020 Navibyte (https://navibyte.com). All rights reserved.
// Use of this source code is governed by a "BSD-3-Clause"-style license, please
// see the LICENSE file.

import 'dart:convert';

import '../../base/crs.dart';
import '../../base/geometry.dart';
import '../../feature/feature.dart';
import '../factory.dart';

/// The default GeoJSON factory instace assuming CRS80 coordinates.
const geoJSON = GeoJsonFactory();

/// A geospatial object factory capable of parsing GeoJSON data from json.
///
/// The implementation expects JSON objects to be compatible with objects
/// generated by the standard `json.decode()`.
///
/// Methods geometry(), feature(), featureSeries() and featureCollections()
/// accepts data object to be either a String (containing valid GeoJSON) or
/// object tree generated by the standard `json.decode()`.
///
/// See [The GeoJSON Format - RFC 7946](https://tools.ietf.org/html/rfc7946).
class GeoJsonFactory extends GeoFactoryBase {
  const GeoJsonFactory({CRS defaultCRS = CRS84})
      : super(
          expectedCRS: defaultCRS,
          expectM: false, // GeoJSON says coordinates should not have M coord
        );

  Map<String, dynamic> _ensureDecodedMap(dynamic data) {
    if (data is String) {
      try {
        data = json.decode(data);
      } catch (e) {
        throw FormatException('Unknown encoding for GeoJSON ($e).');
      }
    }
    if (data is Map<String, dynamic>) {
      return data;
    }
    throw FormatException('Unknown encoding for GeoJSON.');
  }

  Iterable _ensureDecodedList(dynamic data) {
    if (data is String) {
      try {
        data = json.decode(data);
      } catch (e) {
        throw FormatException('Unknown encoding for GeoJSON ($e).');
      }
    }
    if (data is Iterable) {
      return data;
    }
    throw FormatException('Unknown encoding for GeoJSON.');
  }

  @override
  Geometry geometry(dynamic data) {
    // expects data of Map<String, dynamic> as returned by json.decode()
    final json = _ensureDecodedMap(data);
    switch (json['type']) {
      case 'Point':
        return point(json['coordinates']);
      case 'LineString':
        return lineString(json['coordinates']);
      case 'Polygon':
        return polygon(json['coordinates']);
      case 'MultiPoint':
        return multiPoint(json['coordinates']);
      case 'MultiLineString':
        return multiLineString(json['coordinates']);
      case 'MultiPolygon':
        return multiPolygon(json['coordinates']);
      case 'GeometryCollection':
        return geometryCollection(json['geometries']);
    }
    throw FormatException('Not valid GeoJSON geometry.');
  }

  @override
  Feature feature(dynamic data) {
    // expects data of Map<String, dynamic> as returned by json.decode()
    final json = _ensureDecodedMap(data);
    if (json['type'] != 'Feature') {
      throw FormatException('Not valid GeoJSON Feature.');
    }
    // parse geometry for this feature
    // (it's allowed geometry to be null which is mapped to an Geometry.empty)
    final geomJson = json['geometry'];
    final geom = geomJson != null ? geometry(geomJson) : Geometry.empty();
    // create a feature
    try {
      return Feature.of(
        id: json['id'],
        geometry: geom,
        properties: json['properties'],
      );
    } catch (e) {
      throw FormatException('Not valid GeoJSON Feature ($e).');
    }
  }

  @override
  FeatureSeries featureSeries(dynamic data) {
    // expects data of List as returned by json.decode()
    final json = _ensureDecodedList(data);
    return FeatureSeries.from(json.map<Feature>((f) => feature(f)));
  }

  @override
  FeatureCollection featureCollection(dynamic data) {
    // expects data of Map<String, dynamic> as returned by json.decode()
    final json = _ensureDecodedMap(data);
    if (json['type'] != 'FeatureCollection') {
      throw FormatException('Not valid GeoJSON FeatureCollection.');
    }
    return FeatureCollection.of(featureSeries(json['features']));
  }
}
